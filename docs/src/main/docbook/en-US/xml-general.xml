<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="xml">
  <title>Seam XML Reference</title>

 <section>
    <title>OLD Getting Started - To be removed</title>
    <para>By default XML files are discovered from the classpath. The extension looks for an XML file in the following locations:</para>
    <itemizedlist>
    <listitem><literal>/WEB-INF/beans.xml</literal></listitem>
    <listitem><literal>/META-INF/beans.xml</literal></listitem>
    <listitem><literal>/WEB-INF/seam-beans.xml</literal></listitem>
    <listitem><literal>/META-INF/seam-beans.xml</literal></listitem>
    </itemizedlist>
    
    <para>The <literal>beans.xml</literal> file is the preferred way of configuring beans via XML, however it may be possible that some JSR-299 implementations will not allow this, 
    so <literal>seam-beans.xml</literal> is provided as an alternative. </para>
    
    <para>Let's start with a simple example:</para>
    <programlisting role="XML">
    <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:s="urn:java:ee" 
       xmlns:test="urn:java:org.jboss.seam.xml.test.injection">
       
    <test:ProducerQualifier>
        <s:Qualifier/>
    </test:ProducerQualifier>
    
    <test:ProducerBean someOtherField="45" >
        <test:someField>
            <s:Produces/>
            <test:ProducerQualifier/>
            <s:value>hello world</s:value>
        </test:someField>
    </test:ProducerBean>

   <test:ReceiverBean>
        <test:value>
            <test:ProducerQualifier/>
            <s:Inject/>
        </test:value>
   </test:ReceiverBean>
   
</beans>
    ]]>
    </programlisting>
    
    <para>You will notice that two new namspace declarations have been added to the 
      <literal>beans.xml</literal> file: <literal>urn:java:ee</literal> and 
      <literal>urn:java:org.jboss.seam.xml.test.injection</literal>. The 
      <literal>urn:java:ee</literal> namespace is the main one used by the XML 
      extension, we will cover exactly what lives in this namespace later. The 
      <literal>urn:java:org.jboss.seam.xml.test.injection</literal> namespace is used 
      to resolve classes in the java package <literal>org.jboss.seam.xml.test.injection</literal>, 
      so in the example above <literal>&lt;test:ProducerBean&gt;</literal> resolves to 
      <literal>org.jboss.seam.xml.test.injection.ProducerBean</literal>.</para>
      
      <para>It is possible to map an XML namespace to multiple java packages. This is
      done by sperating the packages with a colon like so:</para>
      <programlisting>
        <![CDATA[
        xmlns:test="urn:java:com.mydomain.package1:com.mydomain.package2"
       ]]>
     </programlisting> 
      <para>The namespaces are searched in the order they are specified in the xml 
      document.</para>
      
    <programlisting role="XML">
        <![CDATA[
<test:ProducerQualifier>
    <s:Qualifier/>
</test:ProducerQualifier>
        ]]>
    </programlisting>
    
    <para>The first entry in the file defines a new qualifier. <literal>ProducerQualifier</literal> 
      is an annotation in the package <literal>org.jboss.seam.xml.test.injection</literal>.</para>
    
    <programlisting role="XML">
        <![CDATA[
<test:ProducerBean someOtherField="45" >
    <test:someField>
        <s:Produces/>
        <test:ProducerQualifier/>
        <s:value>hello world</s:value>
    </test:someField>
</test:ProducerBean>
    ]]>
    </programlisting>
    
    <para>The next entry in the file is a bean declaration. The bean class is 
      <literal>org.jboss.seam.xml.test.injection.ProducerBean</literal>. 
    It is important to note that this declaration does not change the existing declaration of 
    <literal>ProducerBean</literal>, instead it installs a new bean. In 
    this instance there will be two <literal>ProducerBean</literal> CDI beans.</para>

    <para>This bean has a field called <literal>someField</literal>, this field is configured to be a producer field using XML (it is also possible to configure producer
     methods, more on this later). The <literal>&lt;test:value/&gt;</literal> declaration has several child elements. The <literal>&lt;s:Produces/&gt;</literal>
     element tells the container that this is a producer field. <literal>&lt;test:ProducerQualifier/&gt;</literal> element defines a qualifier for the producer 
     field. The <literal>&lt;s:value&gt;</literal> element defines an initial value for the field.</para>
    
    <para>This bean also has another field called <literal>someOtherField</literal> this field has it's value to to 45 using a shorthand syntax. A field may not be specified
    	twice, trying to set the value using the shorthand syntax and the normal syntax will result in an error.</para>

    <para>Child elements of fields, methods and classes that resolve to Annotation types are considered to be annotations on the corresponding element, 
    so the corresponding Java declaration for the XML above would be:</para>
    
    <programlisting role="JAVA"><![CDATA[
public class ProducerBean {
   @Produces
   @ProducerQualifier
   public String someField = "hello world";
   
   int someOtherField = 45;
   
}
    ]]></programlisting>
    
    <programlisting role="JAVA"><![CDATA[
<test:ReceiverBean>
    <test:value>
         <test:ProducerQualifier/>
         <s:Inject/>
    </test:value>
</test:ReceiverBean>
    ]]></programlisting>
     
    <para>The XML above declares a new bean that injects the value that was produced above. 
      In this case the <literal>@Inject</literal> annotation is applied instead of
      <literal>@Produces</literal> and no initial value is set.</para>
    </section>
    
    <section>
        <title>XML Namespaces</title>
        <para>The main namesapce is <literal>urn:java:ee</literal> contains builtin tags and types from core packages.
        The builting tags are:</para>
        
        <itemizedlist>
            <listitem><para><literal>Beans</literal></para></listitem>
            <listitem><para><literal>modifies</literal></para></listitem>
            <listitem><para><literal>overrides</literal></para></listitem>
            <listitem><para><literal>parameters</literal></para></listitem>
            <listitem><para><literal>value</literal></para></listitem>
            <listitem><para><literal>key</literal></para></listitem>
            <listitem><para><literal>entry</literal></para></listitem>
            <listitem><para><literal>e</literal> (alias for entry)</para></listitem>
            <listitem><para><literal>v</literal> (alias for value)</para></listitem>
            <listitem><para><literal>k</literal> (alias for key)</para></listitem>
            <listitem><para><literal>array</literal></para></listitem>
            <listitem><para><literal>int</literal></para></listitem>
            <listitem><para><literal>short</literal></para></listitem>
            <listitem><para><literal>long</literal></para></listitem>
            <listitem><para><literal>byte</literal></para></listitem>
            <listitem><para><literal>char</literal></para></listitem>
            <listitem><para><literal>double</literal></para></listitem>
            <listitem><para><literal>float</literal></para></listitem>
            <listitem><para><literal>boolean</literal></para></listitem>
         </itemizedlist>
         
         <para>as well as classes from the following packages:</para>    
         
        <itemizedlist>
            <listitem><para><literal>java.lang</literal></para></listitem>
            <listitem><para><literal>java.util</literal></para></listitem>
            <listitem><para><literal>javax.annotation</literal></para></listitem>
            <listitem><para><literal>javax.inject</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.inject</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.context</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.event</literal></para></listitem>
            <listitem><para><literal>javax.decorator</literal></para></listitem>
            <listitem><para><literal>javax.interceptor</literal></para></listitem>
            <listitem><para><literal>org.jboss.weld.extensions.core</literal></para></listitem>
        </itemizedlist>
        
        <para>Other namspaces are specified using the following syntax:</para>
      <programlisting>
        <![CDATA[xmlns:ns="urn:java:com.mydomain.package1:com.mydomain.package2"]]>
     </programlisting>   
        <para>This maps <literal>ns</literal> to the packages <literal>com.mydomain.package1</literal> 
        and <literal>com.mydomain.package2</literal>. These packages are searched in order to 
        resolve elements in this namespace.</para> 
        <para>For example, say you had a class <literal>com.mydomain.package2.Report</literal>. 
        To configure a <literal>Report</literal> bean you 
        would use <literal>&lt;ns:Report&gt;</literal>. Methods and fields of a bean come 
        from the same namespace as the bean iteself.</para>
    </section>
    
    <section>
        <title>Overriding and extending beans</title>
        <para>By configuring a bean via XML creates a new bean, however there 
          may be cases where you want to modify an existing bean rather than
          adding a new one. The <literal>&lt;s:overrides&gt;</literal> and 
          <literal>&lt;s:modifies&gt;</literal> tags allow you to do this.</para>
          <para>The <literal>&lt;s:overrides&gt;</literal> tag prevents the existing bean from being 
          installed, and registers a new one with the given configuration. The 
          <literal>&lt;s:modifies&gt;</literal> tag does the same, except that it merges
          the annotations on the bean with the annotations defined in XML. This has the
          same effect as modifiying an existing bean.</para>
        
        <programlisting role="XML"><![CDATA[
<test:Report>
	<s:modifies>
	<test:NewQualifier/>
</test:Report>

<test:ReportDatasource>
	<s:replaces>
	<test:NewQualifier/>
</test:ReportDatasource>]]>
        </programlisting>
        <para>The first entry above adds a new bean with an extra qualifier, in addition to the qualifiers already present, 
        and prevents the existing <literal>Report</literal> bean from being installed.</para> 
        <para>The second prevents the existing bean from being installed, and registers a new bean with a single qualifier.</para>
    </section>
    
    <section>
        <title>Initial Field Values</title>
        <para>Inital field values can be set three different ways as shown below:</para>
        <programlisting role="XML">
            <![CDATA[
<r:MyBean company="Red Hat Inc" />

<r:MyBean>
  <r:company>Red Hat Inc</r:company>
</r:MyBean>

<r:MyBean>
  <r:company>
  	<s:value>Red Hat Inc<s:value>
  	<r:SomeQualifier/>
  </r:company>
</r:MyBean>]]>
        </programlisting>

        <para>The third form is the only one that also allows you to add annotations such as qualifiers to the field.</para>

        <para>It is possible to set <literal>Map</literal>,<literal>Array</literal> and <literal>Collection</literal> field values. Some examples:</para>
        <programlisting role="XML">
            <![CDATA[	
<test:ArrayFieldValue>

    <test:iarray>
        <s:value>1</s:value>
        <s:value>2</s:value>
    </test:iarray>
    
    <test:carray>
        <s:value>java.lang.Integer</s:value>
        <s:value>java.lang.Long</s:value>
    </test:carray>
    
    <test:sarray>
        <s:value>hello</s:value>
        <s:value>world</s:value>
    </test:sarray>
    
</test:ArrayFieldValue>

<test:MapFieldValue>

    <test:map1>
        <s:entry><s:key>1</s:key><s:value>hello</s:value></s:entry>
        <s:entry><s:key>2</s:key><s:value>world</s:value></s:entry>
    </test:map1>
    
    <test:map2>
        <s:e><s:k>1</s:k><s:v>java.lang.Integer</s:v></s:e>
        <s:e><s:k>2</s:k><s:v>java.lang.Long</s:v></s:e>
    </test:map2>
    
</test:MapFieldValue>
          ]]>
          </programlisting>
        <para>Type conversion is done automatically for all primitives and primitive wrappers, <literal>Date</literal>, 
        <literal>Calendar</literal>,<literal>Enum</literal> and <literal>Class</literal> fields. 
        In this instance <literal>ArrayFieldValue.carray</literal> is actually an array of classes, not an array of Strings.</para>
    </section>
    <section>
        <title>Configuring methods</title>
    
        <para>It is also possible to configure methods in a similar way to configuring fields:</para>
        <programlisting role="XML" >
            <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:s="urn:java:ee" 
       xmlns:test="urn:java:org.jboss.seam.xml.test.method">
    <test:MethodBean>
    
        <test:doStuff>
            <s:Produces/>
        </test:doStuff>
        
        <test:doStuff>
            <s:Produces/>
            <test:Qualifier1/>
            <s:parameters>
                <test:MethodValueBean>
                    <test:Qualifier2/>
                </test:MethodValueBean>
            </s:parameters>
        </test:doStuff>
        
        <test:doStuff>
            <s:Produces/>
            <test:Qualifier1/>
            <s:parameters>
                <s:array dimensions="2">
                    <test:Qualifier2/>
                    <test:MethodValueBean/>
                </s:array>
            </s:parameters>
        </test:doStuff>
        
    </test:MethodBean>
</beans>
]]>
</programlisting>
<programlisting role="JAVA" >
<![CDATA[
public class MethodBean {

   public int doStuff() {
      return 1;
   }

   public int doStuff(MethodValueBean bean) {
      return bean.value + 1;
   }
   
   public void doStuff(MethodValueBean[][] beans) {
      //do stuff
   }

}
]]>
</programlisting>
            
        <para>In this instance <literal>MethodBean</literal> has three methods, all of them rather 
        imaginatively named <literal>doStuff</literal>.</para>
        <para> The first <literal>&lt;test:doStuff&gt;</literal> 
        entry in the XML file configures the method that takes no arguments. The 
        <literal>&lt;s:Produces&gt;</literal> element makes it into a producer method. 
        </para>
        <para>The next entry in the file configures the method that takes a 
        <literal>MethodValueBean</literal> as a parameter and the final entry 
        configures a method that takes a two dimensional array of<literal>MethodValueBean</literal>'s
        as a parameter. For both these methods a qualifier was added to the method parameter and
        they were made into producer methods.</para>
        <para>Method parameters are specified inside the <literal>&lt;s:parameters&gt;</literal>
        element. If these parameters have annotation children they are taken to be annotations on 
        the parameter. </para> 
        
        <para>The corresponding Java declaration for the XML above would be:</para>
        <programlisting role="JAVA">
            <![CDATA[
public class MethodBean {
            
	@Produces
	public int doStuff() {//method body}            
	            
	@Produces
	@Qualifier1
	public int doStuff(@Qualifier2 MethodValueBean param) {//method body}
	
	@Produces
	@Qualifier1
	public int doStuff(@Qualifier2 MethodValueBean[][] param) {//method body}
}           ]]>
         </programlisting>
         <para>Array parameters can be represented using the <literal>&lt;s:array&gt;</literal> element, 
         with a child element to represent the type of the array. E.g.</para>
         <programlisting role="JAVA">
int method(MethodValueBean[] param);
         </programlisting>        
        <para>could be configured via xml using the following:</para>
        <programlisting role="XML">
            <![CDATA[
<test:method>
    <s:array>
      <test:MethodValueBean/>
    </s:array>
</test:method>
        ]]>
        </programlisting>
    </section>
    
    <section>
        <title>Overriding the type of an injection point</title>
        
        <para>It is possible to limit which bean types are availible to inject int a given injection point:</para>
             <programlisting role="JAVA">
                  <![CDATA[
public class SomeBean
{
	public Object someField;
}                  
]]>
</programlisting>
<programlisting role="XML">
<![CDATA[                 
<test:SomeBean>
        <test:someField>
         	<s:Inject/>
         	<s:Exact>com.mydomain.InjectedBean</s:Exact>
        </test:someField>
</test:SomeBean>
]]>
</programlisting>
<para>In the example above only beans that are assignable to InjectedBean will be eligable for injection into the field.
	 This also works for parameter injection points.</para>
        
    </section>    
    
    <section>
        <title>Annotation Members</title>
        <para>It is possible to set the value of annotation members using attributes in xml. For example:</para>
        <programlisting role="JAVA" >
            <![CDATA[
public @interface OtherQualifier {
   String value1();
   int value2();
   QualifierEnum value();
}
]]>
</programlisting>
<programlisting role="XML" >
<![CDATA[
<test:QualifiedBean1>
        <test:OtherQualifier value1="AA" value2="1">A</test:OtherQualifier>
</test:QualifiedBean1>
    
<test:QualifiedBean2>
        <test:OtherQualifier value1="BB" value2="2" value="B" />
</test:QualifiedBean2>
]]>
        </programlisting>
        <para>The value member can be set using the inner text of the node, as seen in the first example.</para>
    </section>
    
    <section>
    	<title>Configuring Meta Annotations</title>
    	<para>It is possible to make existing annotations into qualifiers, stereotypes or interceptor bindings.</para>
    	<para>This configures a stereotype annotation <literal>SomeStereotype</literal> that has a single interceptor 
    	binding and is named:</para>
<programlisting role="XML" >
<![CDATA[
   <test:SomeStereotype>
        <s:Stereotype/>
        <test:InterceptorBinding/>
        <s:Named/>
   </test:SomeStereotype>
]]>
</programlisting>   
<para>This configures a qualifier annotation:</para>
<programlisting role="XML" >
<![CDATA[
   <test:SomeQualifier>
        <s:Qualifier/>
   </test:SomeQualifier>
]]>
</programlisting>    	
<para>This configures an interceptor binding:</para>
<programlisting role="XML" >
<![CDATA[
   <test:SomeInterceptorBinding>
        <s:InterceptorBinding/>
   </test:SomeInterceptorBinding>
]]>
</programlisting>  
    </section>
    
    
    <section>
    	<title>Generic Beans</title>
    	<para>Gereric beans allow for multiple beans to be created from a single bean definition. They are 
    	designed for use by framework writers. From the users perspective there is no
    	special configuration required, if you configure a bean that a framework writer has marked as a generic
    	bean then you will end up with multiple beans instead.</para>
    	<para>Generic beans are configured using the syntax described above. For every bean that the user 
    	configures, a corresponding bean from the generic bean declaration is created. For example in the 
    	framework xml configuration:</para>
<programlisting role="XML" >
            <![CDATA[
<s:genericBean class="org.jboss.seam.xml.test.generic.GenericMain" >
	<test:GenericDependant>
		<s:ApplyQualifiers/>
		<s:modifies/>
		<test:instance>
			<s:ApplyQualifiers/>
		</test:instance>
	</test:GenericDependant>
</s:genericBean>
]]>
        </programlisting>    
        <para>The declaration above means that for every <literal>GenericMain</literal> that a user configures via xml 
        a corresponding <literal>GenericDependant</literal> is created as well. The 
        <literal>&lt;s:ApplyQualifiers\&gt;</literal> is replaced with the qualifiers that are present on the user 
        configured bean.</para>
    </section>
    
   
    <section>
        <title>More Information</title>
        <para>For further information look at the units tests in the seam-xml distribution, also the 
          JSR-299 Public Review Draft section on XML Configuration was the base for this extension, 
        so it may also be worthwhile reading.</para>
    </section>
    
</chapter>
