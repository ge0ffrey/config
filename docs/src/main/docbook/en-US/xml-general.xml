<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="xml">
  <title>Seam XML General</title>
  
  <para>Seam provides a method for configuring JSR-299 beans using XML. Using XML it is possible to add new beans, override existing beans, and add 
  extra configuration to existing beans. The default is to add a new bean.
  </para>
  
 <section>
    <title>Configuration</title>
    <para>No special configuration is required to use seam-xml, all that is required is to include the jar file and the weld extensions jar in your deployment. </para>
 </section>
 
 <section>
    <title>Getting Started</title>
    <para>By default XML files are discovered from the classpath. The extension looks for an XML file in the following locations:</para>
    <itemizedlist>
    <listitem><literal>/WEB-INF/beans.xml</literal></listitem>
    <listitem><literal>/META-INF/beans.xml</literal></listitem>
    <listitem><literal>/WEB-INF/seam-beans.xml</literal></listitem>
    <listitem><literal>/META-INF/seam-beans.xml</literal></listitem>
    </itemizedlist>
    
    <para>The <literal>beans.xml</literal> file is the preferred way of configuring beans via XML, however it may be possible that some JSR-299 implementations will not allow this, 
    so <literal>seam-beans.xml</literal> is provided as an alternative. </para>
    
    <para>Let's start with a simple example:</para>
    <programlisting>
    <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:s="urn:java:seam:core" 
       xmlns:test="urn:java:org.jboss.seam.xml.test.injection">
       
    <test:ProducerQualifier>
        <s:Qualifier/>
    </test:ProducerQualifier>
    
    <test:ProducerBean someOtherField="45" >
        <test:someField>
            <s:Produces/>
            <test:ProducerQualifier/>
            <s:value>hello world</s:value>
        </test:someField>
    </test:ProducerBean>

   <test:ReceiverBean>
        <test:value>
            <test:ProducerQualifier/>
            <s:Inject/>
        </test:value>
   </test:ReceiverBean>
   
</beans>
    ]]>
    </programlisting>
    
    <para>You will notice that two new namspace declarations have been added to the 
      <literal>beans.xml</literal> file: <literal>urn:java:seam:core</literal> and 
      <literal>urn:java:org.jboss.seam.xml.test.injection</literal>. The 
      <literal>urn:java:seam:core</literal> namespace is the main one used by the XML 
      extension, we will cover exactly what lives in this namespace later. The 
      <literal>urn:java:org.jboss.seam.xml.test.injection</literal> namespace is used 
      to resolve classes in the java package <literal>org.jboss.seam.xml.test.injection</literal>, 
      so in the example above <literal>&lt;test:ProducerBean&gt;</literal> resolves to 
      <literal>org.jboss.seam.xml.test.injection.ProducerBean</literal>.</para>
      
      <para>It is possible to map an XML namespace to multiple java packages. This is
      done by sperating the packages with a colon like so:</para>
      <programlisting>
        <![CDATA[
        xmlns:test="urn:java:com.mydomain.package1:com.mydomain.package2"
       ]]>
     </programlisting> 
      <para>The namespaces are searched in the order they are specified in the xml 
      document.</para>
      
    <programlisting>
        <![CDATA[
<test:ProducerQualifier>
    <s:Qualifier/>
</test:ProducerQualifier>
        ]]>
    </programlisting>
    
    <para>The first entry in the file defines a new qualifier. <literal>ProducerQualifier</literal> 
      is an annotation in the package <literal>org.jboss.seam.xml.test.injection</literal>.</para>
    
    <programlisting>
        <![CDATA[
<test:ProducerBean someOtherField="45" >
    <test:someField>
        <s:Produces/>
        <test:ProducerQualifier/>
        <s:value>hello world</s:value>
    </test:someField>
</test:ProducerBean>
    ]]>
    </programlisting>
    
    <para>The next entry in the file is a bean declaration. The bean class is 
      <literal>org.jboss.seam.xml.test.injection.ProducerBean</literal>. 
    It is important to note that this declaration does not change the existing declaration of 
    <literal>ProducerBean</literal>, instead it installs a new bean. In 
    this instance there will be two <literal>ProducerBean</literal> CDI beans.</para>

    <para>This bean has a field called <literal>someField</literal>, this field is configured to be a producer field using XML (it is also possible to configure producer
     methods, more on this later). The <literal>&lt;test:value/&gt;</literal> declaration has several child elements. The <literal>&lt;s:Produces/&gt;</literal>
     element tells the container that this is a producer field. <literal>&lt;test:ProducerQualifier/&gt;</literal> element defines a qualifier for the producer 
     field. The <literal>&lt;s:value&gt;</literal> element defines an initial value for the field.</para>
    
    <para>This bean also has another field called <literal>someOtherField</literal> this field has it's value to to 45 using a shorthand syntax. A field may not be specified
    	twice, trying to set the value using the shorthand syntax and the normal syntax will result in an error.</para>

    <para>Child elements of fields, methods and classes that resolve to Annotation types are considered to be annotations on the corresponding element, 
    so the corresponding Java declaration for the XML above would be:</para>
    
    <programlisting><![CDATA[
public class ProducerBean {
   @Produces
   @ProducerQualifier
   public String someField = "hello world";
   
   int someOtherField = 45;
   
}
    ]]></programlisting>
    
    <programlisting><![CDATA[
<test:ReceiverBean>
    <test:value>
         <test:ProducerQualifier/>
         <s:Inject/>
    </test:value>
</test:ReceiverBean>
    ]]></programlisting>
     
    <para>The XML above declares a new bean that injects the value that was produced above. 
      In this case the <literal>@Inject</literal> annotation is applied instead of
      <literal>@Produces</literal> and no initial value is set.</para>
    </section>
    
    <section>
        <title>The main namespace</title>
        <para>The main namesapce is <literal>urn:java:seam:core</literal> can contain the following elements:</para>
        
        <itemizedlist>
            <listitem><para><literal>Beans</literal></para></listitem>
            <listitem><para><literal>specializes</literal></para></listitem>
            <listitem><para><literal>overrides</literal></para></listitem>
            <listitem><para><literal>parameters</literal></para></listitem>
            <listitem><para><literal>value</literal></para></listitem>
            <listitem><para><literal>key</literal></para></listitem>
            <listitem><para><literal>entry</literal></para></listitem>
            <listitem><para><literal>e</literal> (alias for entry)</para></listitem>
            <listitem><para><literal>v</literal> (alias for value)</para></listitem>
            <listitem><para><literal>k</literal> (alias for key)</para></listitem>
            <listitem><para><literal>array</literal></para></listitem>
            <listitem><para><literal>int</literal></para></listitem>
            <listitem><para><literal>short</literal></para></listitem>
            <listitem><para><literal>long</literal></para></listitem>
            <listitem><para><literal>byte</literal></para></listitem>
            <listitem><para><literal>char</literal></para></listitem>
            <listitem><para><literal>double</literal></para></listitem>
            <listitem><para><literal>float</literal></para></listitem>
            <listitem><para><literal>boolean</literal></para></listitem>
         </itemizedlist>
         
         <para>as well as classes from the following packages:</para>    
         
        <itemizedlist>
            <listitem><para><literal>java.lang</literal></para></listitem>
            <listitem><para><literal>java.util</literal></para></listitem>
            <listitem><para><literal>javax.annotation</literal></para></listitem>
            <listitem><para><literal>javax.inject</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.inject</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.context</literal></para></listitem>
            <listitem><para><literal>javax.enterprise.event</literal></para></listitem>
            <listitem><para><literal>javax.decorator</literal></para></listitem>
            <listitem><para><literal>javax.interceptor</literal></para></listitem>
        </itemizedlist>
        
        <para>So the <literal>&lt;s:Produces&gt;</literal> element above actually resolves 
        to <literal>java.enterprise.inject.Produces</literal> 
        and the <literal>&lt;s:Inject&gt;</literal> element resolves to <literal>javax.inject.Inject</literal>.</para>
        
    </section>
    
    <section>
        <title>Overriding and extending beans</title>
        <para>There may be cases where you want to modify an existing bean rather than
          adding a new one. The <literal>&lt;s:overrides&gt;</literal> and 
          <literal>&lt;s:specializes&gt;</literal> tags allow you to do this. The 
          <literal>&lt;s:overrides&gt;</literal> tag prevents the existing bean from being 
          installed, and registers a new one with the given configuration. The 
          <literal>&lt;s:specializes&gt;</literal> tag allows you to add extra configuration 
          to an existing bean.</para>
        
        <programlisting><![CDATA[
<test:MyBean>
	<s:specializes>
	<test:NewQualifier/>
</test:MyBean>

<test:OtherBean>
	<s:overrides>
	<test:NewQualifier/>
</test:OtherBean>
              ]]>
        </programlisting>
        <para>The first entry above adds a new qualifier to an existing bean definition. The second prevents the existing bean from being installed, and registers a new bean with a single qualifier.</para>
    </section>
    
    <section>
        <title>Initial Field Values</title>
        <para>Inital field values can be set in two different ways, in addition to the <literal>&lt;s:value&gt;</literal> element shown above it can be set as follows:</para>
        <programlisting>
            <![CDATA[
<test:someField>hello world</test:someField>
             ]]>
        </programlisting>

        <para>Using this method prevents you from adding any annotations to the field.</para>

        <para>It is possible to set <literal>Map</literal>,<literal>Array</literal> and <literal>Collection</literal> field values. Some examples:</para>
        <programlisting>
            <![CDATA[
<test:ArrayFieldValue>
    <test:iarray>
        <s:value>1</s:value>
        <s:value>2</s:value>
    </test:iarray>
    <test:carray>
        <s:value>java.lang.Integer</s:value>
        <s:value>java.lang.Long</s:value>
    </test:carray>
    <test:sarray>
        <s:value>hello</s:value>
        <s:value>world</s:value>
    </test:sarray>
</test:ArrayFieldValue>

<test:MapFieldValue>
    <test:map1>
        <s:entry><s:key>1</s:key><s:value>hello</s:value></s:entry>
        <s:entry><s:key>2</s:key><s:value>world</s:value></s:entry>
    </test:map1>
    <test:map2>
        <s:e><s:k>1</s:k><s:v>java.lang.Integer</s:v></s:e>
        <s:e><s:k>2</s:k><s:v>java.lang.Long</s:v></s:e>
    </test:map2>
</test:MapFieldValue>
          ]]>
          </programlisting>
        <para>Type conversion is done automatically for all primitives and primitive wrappers, <literal>Date</literal>, 
        <literal>Calendar</literal>,<literal>Enum</literal> and <literal>Class</literal> fields. 
        In this instance <literal>ArrayFieldValue.carray</literal> is actually an array of classes, not an array of Strings.</para>

    </section>
    <section>
        <title>Configuring methods</title>
    
        <para>It is also possible to configure methods in a similar way to configuring fields:</para>
        <programlisting>
            <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:s="urn:java:seam:core" 
       xmlns:test="urn:java:org.jboss.seam.xml.test.method">
    <test:MethodBean>
        <test:method>
            <s:Produces/>
        </test:method>
        <test:method>
            <s:Produces/>
            <test:Qualifier1/>
            <s:parameters>
                <test:MethodValueBean>
                    <test:Qualifier2/>
                </test:MethodValueBean>
            </s:parameters>
        </test:method>
         <test:method>
            <s:Produces/>
            <test:Qualifier1/>
            <s:parameters>
                <s:array dimensions="2">
                    <test:Qualifier2/>
                    <test:MethodValueBean/>
                </s:array>
            </s:parameters>
        </test:method>
    </test:MethodBean>
</beans>

public class MethodBean {

   public int method() {
      return 1;
   }

   public int method(MethodValueBean bean) {
      return bean.value + 1;
   }
   
   public void method(MethodValueBean[][] beans) {
      //do stuff
   }

}

            ]]>
        </programlisting>

        <para>In this instance <literal>MethodBean</literal> has three methods, all of them rather 
        imaginatively named <literal>method</literal>. The first <literal>&lt;test:method&gt;</literal> 
        entry in the XML file configures the method that takes no arguments. The 
        <literal>&lt;s:Produces&gt;</literal> element makes it into a producer method. The next 
        entry in the file configures the method that takes a <literal>MethodValueBean</literal> 
        as a parameter. The final entry configures a method that takes a two
        dimensional array of<literal>MethodValueBean</literal>'s as a parameter.  
        Method parameters are specified inside the <literal>&lt;s:parameters&gt;</literal>
        element. If these parameters have annotation children they are taken to be annotations on 
        the parameter. </para> 
        
        <para>The corresponding Java declaration for the XML above would be:</para>
        <programlisting>
            <![CDATA[
@Produces
public int method() {//method body}            
            
@Produces
@Qualifier1
public int method(@Qualifier2 MethodValueBean param) {//method body}

@Produces
@Qualifier1
public int method(@Qualifier2 MethodValueBean[][] param) {//method body}
           ]]>
         </programlisting>
         <para>Array parameters can be represented using the <literal>&lt;s:array&gt;</literal> element, 
         with a child element to represent the type of the array. E.g.</para>
         <programlisting>
int method(MethodValueBean[] param);
         </programlisting>        
        <para>could be configured via xml using the following:</para>
        <programlisting>
            <![CDATA[
<test:method>
    <s:array>
      <test:MethodValueBean/>
    </s:array>
</test:method>
        ]]>
        </programlisting>
    </section>
    
    <section>
        <title>Overriding the type of an injection point</title>
        
        <para>It is possible to limit which bean types are availible to inject int a given injection point:</para>
             <programlisting>
                  <![CDATA[
                  
public class SomeBean
{
	public Object someField;
}                  
                  
<test:SomeBean>
        <test:someField>
         	<s:Inject/>
         	<s:type>
         		<test:InjectedBean/>
         	</s:type>
        </test:someField>
</test:SomeBean>
]]>
</programlisting>
<para>In the example above only beans that are assignable to InjectedBean will be eligable for injection into the field.
	 This also works for parameter injection points.</para>
        
    </section>    
    
    <section>
        <title>Annotation Members</title>
        <para>It is possible to set the value of annotation members using attributes in xml. For example:</para>
        <programlisting>
            <![CDATA[
public @interface OtherQualifier {
   String value1();
   int value2();
   QualifierEnum value();
}


<test:QualifiedBean1>
        <test:OtherQualifier value1="AA" value2="1">A</test:OtherQualifier>
</test:QualifiedBean1>
    
<test:QualifiedBean2>
        <test:OtherQualifier value1="BB" value2="2" value="B" />
</test:QualifiedBean2>
]]>
        </programlisting>
        <para>The value member can be set using the inner text of the node, as seen in the first example.</para>
    </section>
    
    <section>
    	<title>Generic Beans</title>
    	<para>Gereric beans allow for multiple beans to be created from a single bean definition. They are 
    	designed for use by framework writers. From the users perspective there is no
    	special configuration required, if you configure a bean that a framework writer has marked as a generic
    	bean then you will end up with multiple beans instead.</para>
    	<para>Generic beans are configured using the syntax described above. For every bean that the user 
    	configures, a corresponding bean from the generic bean declaration is created. For example in the 
    	framework xml configuration:</para>
<programlisting>
            <![CDATA[
<s:genericBean class="org.jboss.seam.xml.test.generic.GenericMain" >
	<test:GenericDependant>
		<s:ApplyQualifiers/>
		<s:specializes/>
		<test:instance>
			<s:ApplyQualifiers/>
		</test:instance>
	</test:GenericDependant>
</s:genericBean>
]]>
        </programlisting>    
        <para>The declaration above means that for every <literal>GenericMain</literal> that a user configures via xml 
        a corresponding <literal>GenericDependant</literal> is created as well. The 
        <literal>&lt;s:ApplyQualifiers\&gt;</literal> is replaced with the qualifiers that are present on the user 
        configured bean.</para>
    </section>
    
   
    <section>
        <title>More Information</title>
        <para>For further information look at the units tests in the seam-xml distribution, also the 
          JSR-299 Public Review Draft section on XML Configuration was the base for this extension, 
        so it may also be worthwhile reading.</para>
    </section>
    
</chapter>
